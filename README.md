# Shop-Finder主要功能  
## 一、短息校验登陆  
传统session登陆弊端：在多服务器（分布式）情况下，登陆信息难以实现共享和同步  
核心功能：改进基本的session登陆，使用redis和双重拦截器完成登陆校验和登陆状态的刷新，其中利用redis来实现登陆信息的多服务器共享和同步  
![image](https://github.com/woshimax/Shop-Finder/blob/master/img/login.png)
## 二、商户查询缓存  
最基本的使用缓存的思路：先查缓存，命中则直接返回，未命中则查数据库，存到缓存中，然后返回

解决缓存相关问题
### 1、一致性问题
弱一致性：设置redis的ttl即可，自动删除  
强一致性：需要在更新操作时，手动删除这一条数据  
### 2、缓存穿透  
查缓存中和数据库中都不存在的内容，导致这些请求被一直打到数据库，缓存失效（被穿透了）  
解决方式：空值法——将这个无效key也设置一个value，但是是一个“空”value，以后再有这种key访问，就不会打到数据库，一定程度解决穿透问题  
### 3、缓存击穿问题  
热点key过期，导致访问热点key的请求被直接打到数据库，缓存失效  
解决方式：可以设置永不过期，后台进行更新；也可以使用互斥锁（Redis自带的setnx操作就行）限制对同一条数据对操作，防止大量请求同时访问一个过期的数据导致击穿；也可以提前预热，在热点key过期之间提前刷新缓存，保证始终在缓存中  
互斥锁解决方案的关键点：获取锁成功后需要再做一次redis查询，保证在一个线程更新缓存之后，另一个线程能直接用最新的缓存，而不需要再查数据库  

其中缓存穿透和缓存击穿其实都是在未命中的时候，需要我们去使用相关方式去解决  
![image](https://github.com/woshimax/Shop-Finder/blob/master/img/shop_get.png)
## 三、优惠券秒杀  

### 1、解决超卖问题  
利用乐观锁（CAS）  
### 2、解决一人一单问题  
根据id（字符串形式-因为Long的话值同但是对象不同）+同步代码块加锁解决单机状态下的一人一单问题，再利用Redis解决多机状态下的一人一单问题  
详细说明Redis解决多机下的一人一单问题：  
问题1:假如有两个线程，线程1在拿到锁之后执行业务，但由于业务超时导致Redis自动释放锁，此时线程2拿到锁执行业务，但在线程2执行业务过程中，线程1业务完成，并释放锁，此时会造成线程2锁的误删  
解决方案：在释放锁的方法中添加唯一校验，UUID+线程ID校验是否是当前线程  
问题2:在判断是否是当前线程和释放锁操作之间如果出现超时情况，也会造成误删  
解决方案：利用lua脚本，将判断和释放操作设置成一个原子性操作，可以一起执行，避免误删  
### 3、异步秒杀  
一个线程处理校验操作（处理比较快的操作），一个线程处理创建订单操作（处理比较慢，涉及数据库的操作）  
其中，判断库存和一人一单交给Redis的lua脚本判断：判断通过则开启异步线程处理订单，并返回订单id；判断不通过则返回异常信息  
在处理订单这里设置消息队列：第一次使用java自带阻塞队列，适用于单机；第二次进行优化：用Redis的Stream模拟消息队列  
![image](https://github.com/woshimax/Shop-Finder/blob/master/img/order.png)



